+--
utilizando o curl para requisições http
-X POST : verbo da requisição
-v      : resposta verbosa com headers e body
-H      : cabeçalhos
-d      : corpo

curl http://localhost:3000/pagamentos/pagamento
    -X POST
    -v
    -H "Content-type: application/json"
    -d '{
        "forma_de_pagamento": "payfast",
        "valor": "10.87",
        "moeda": "BRL",
        "descricao": "descrição do pagamento"
    }'

curl http://localhost:3000/pagamentos/pagamento
    -X POST
    -v
    -H "Content-type: application/json"
    -d @files/pagamento.json

copy/paste cmd
literal:
    curl http://localhost:3000/pagamentos/pagamento -X POST -v -H "Content-type: application/json" -d "{\"forma_de_pagamento\": \"payfast\", \"valor\": \"10.87\", \"moeda\": \"BRL\", \"descricao\": \"descrição do pagamento\"}"
file:
    curl http://localhost:3000/pagamentos/pagamento -X POST -v -H "Content-type: application/json" -d @files/pagamento.json
=--

+--
status code HTTP importante para api REST:
100 Continue: o servidor recebeu a solicitação e o cliente pode continuar a comunicação.
200 Ok: tudo ocorreu como esperado.
201 Created: um novo recurso foi criado no servidor.
301 Moved: a url solicitada foi movida.
400 Bad Request: problemas na requisição do cliente.
404 Not Found: a url solicitada não foi encontrada.
500 Internal Server Error: algo inesperado aconteceu do lado do servidor
=--

+--
A sigla REST vêm de Representational State Transfer e surgiu da tese de doutorado de Roy Fielding, descrevendo as ideias que levaram à criação do protocolo HTTP. A Web é o maior exemplo de uso de uma arquitetura REST, onde os verbos são as operações disponíveis no protocolo (GET, POST, DELETE, PUT, OPTION...), os recursos são identificados pelas URLs e as representações podem ser definidas com o uso de Mime Types(texto, XML, JSON e outros).
=--

+--
Métodos HTTP
GET: retorna uma representação do recurso
POST: cria ou altera o recurso
PUT: cria ou altera o recurso
DELETE: remove o recurso
outras menos comuns, como HEAD e OPTIONS

Os quatro principais verbos do protocolo HTTP são comumente associados às operações de CRUD em sistemas Restful (POST -> INSERT, GET -> SELECT, PUT -> UPDATE, DELETE -> DELETE). Há uma grande discussão dos motivos pelos quais usamos POST para criação (INSERT) e PUT para alteração (UPDATE). A razão principal é que o protocolo HTTP especifica que a operação PUT deve ser idempotente, já POST não.

Idempotência e SAFE
Operações idempotentes são operações que podem ser chamadas uma ou mais vezes, sempre com o mesmo resultado final.

Uma operação é chamada SAFE se ela não altera nenhuma representação.

Idempotência e SAFE são propriedades das operações e fundamentais para a escalabilidade da Web.
=--

+--
Hipermídia
Os recursos serão apresentados por meio de representações. Seguindo os princípios RESTful, representações devem ser interligadas umas com a outras. Isso é chamado hipermídia e conhecido na Web através de hyperlinks. No nosso exemplo, a representações de um livro poderia conter a URI dos autores. Como resultado disso, é possível navegar entre os recursos.

Mais sobre hipermídia no blog da Caelum:

http://blog.caelum.com.br/hipermidia-e-contratos-dinamicos-menor-acoplamento/

RESTful
Qualquer sistema que aplique as ideias do estilo arquitetural REST, pode ser chamado de RESTful. Existe uma intensa discussão na comunidade sobre quando um sistema pode ser considerado RESTful ou não, porém, na maioria dos casos, basta apenas implantar uma parte do REST (em especial pensar em recursos, verbos fixos e ligações entre apresentações) para ser chamado de RESTfull
=--

+--
Coreografia de serviços com HATEOAS
Um pagamento nasce a partir de uma transação com estado CRIADO e pode ser CONFIRMADO ou CANCELADO pelo cliente. Confirmar representa um "próximo passo" na vida do pagamento e pode ou não ser seguido pelo cliente. A ideia principal é que um recurso informe ao cliente quais os próximos passos ou relacionamentos, e atrás de cada relacionamento há um serviço transformador de dados.

Uma vez criado um pagamento vamos então receber os dados dele e também os relacionamentos:
{
    "id":3,"status":"CRIADO","valor":29.9,
    "links":[
        {"rel":"confirmar","uri":"/pagamentos/pagamento/3","method":"PUT"},
        {"rel":"cancelar","uri":"/pagamentos/pagamento/3","method":"DELETE"}
    ]
}
No entanto, um pagamento no estado CONFIRMADO, podemos pedir apenas informações sobre o pagamento. Assim, a apresentação do recurso, além dos dados, também leva sempre as informações sobre o que é permitido executar:
{
    "id":3,"status":"CONFIRMADO","valor":29.9,
    "links":[
        {"rel":"self","uri":"/pagamentos/pagamento/3","method":"GET"}
    ]
}
Essa forma de juntar os dados às ações é conhecida como hypermedia e é a essência do HATEOAS - Hypermedia as the Engine of Application State.

Para que seja aplicado o HATEOAS ao PayFast basta que cada rota passe a adicionar no body do seu response as informações com os próximos links possíveis a serem seguidos após a requisição que foi feita.
=--

+--
O restify simplifica bastante a vida para consumir serviços REST, mas lembre sempre que serviços REST nada mais são do que integração via HTTP, então qualquer chamada via request HTTP normal também deveria funcionar normalmente.
=--

+--
Streaming de dados
Muitas das apis assíncronas utilizadas no Node.js trabalham utilizando o chamado buffer mode. Em uma operação de entrada de dados o buffer mode faz com que todos os dados oriundos da requisição fiquem armazenados em um buffer. Para que então seja passado para algum callback tão somente todo o recurso tenha sido lido.

Esse tipo de estratégia não é muito interessante para o Node.js, visto que ele é pensando para trabalhar com operações de I/O e faz isso muito bem, mas quando a necessidade é ficar manipulando muito recurso na memória, que é o que fazem os buffers, ele passa a perder bastante performance.

A solução ideal para resolver essa questão seria conseguir ir processando os dados conforme eles fossem chegando, ao invés de ter que esperar a leitura do dado por inteiro. É exatamente isso que a api de Streams do Node.js possibilita ao programador.

Existem diversas vantagens em se utilizar essa api sempre que possível. Veja as principais:

Eficiência espacial
Primeiro de tudo, os Streams nos permitem fazer coisas que não seriam possíveis somente bufferizando dados processando-os todos de uma vez.

Por exemplo: imagine que a aplicação precise ler arquivos muito grandes da ordem dos mega ou até gigabytes. Agora imagine que a aplicação precise ler alguns desses arquivos de forma concorrente. Claramente utilizar uma api que retorna um grande buffer quando o arquivo está completamente lido não é uma boa ideia. A aplicação iria fatalmente cair por falta de memória.

Além disso, os buffers na V8, a runtime sobre a qual o Node.js roda, suporta como tamanho máximo para buffers um número que sequer chega a 1 GB de memória. Ou seja a aplicação esbarraria em uma limitação do próprio ambiente antes mesmo de chegar ao limite físico de memória.

Utilizar Streams nessa situação reduz em muito o uso de memória da aplicação e faz com que ela rode de uma maneira mais suave.

Eficiência temporal
Vamos considerar agora o caso de uma aplicação que precisa comprimir um arquivo e após fazer o seu upload para um servidor HTTP remoto. Este servidor então recebe o arquivo, descompacta e salva-o em seu sistema de arquivos.

Se o cliente tiver sido implementando utilizando uma api com buffers, o upload só iria iniciar uma vez que o arquivo inteiro tenha sido lido e compactado. Do outro lado e descompressão também só iria ter início uma vez que o arquivo inteiro tenha sido recebido.

Uma melhor solução seria implementar a mesma funcionalidade com streams. Do lado do cliente, os streams permitem que aplicação vá lendo e enviando os arquivos conforme eles forem sendo lidos do sistema de arquivos. E do lado do servidor ela permite que seja feita a descompactação de cada pedaço de arquivo, conforme eles vão sendo recebidos do cliente remoto. Esses pedaços costumam ser chamados de chunks.

É bem fácil perceber que a abordagem com streams gera um ganho de tempo gigantesco e que escala bem melhor.
=--